// Generated by .NET Reflector from D:\workspace\mobile\hito-mobile\HitoApp\lampart_lib_dll\DevExpress.XamarinForms.Grid.dll
namespace DevExpress.XamarinForms.DataGrid.Internal
{
    using DevExpress.Compatibility.System;
    using DevExpress.Data;
    using DevExpress.XamarinForms.DataGrid;
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Runtime.CompilerServices;
    
    public abstract class SortedGridDataSourceBase : TransformationGridDataSource
    {
        private SortDescriptor<IRowData> comparer;
        
        protected SortedGridDataSourceBase()
        {
        }
        
        protected virtual void AssignSortDescriptor(SortDescriptor<IRowData> value)
        {
            this.SetSortDescriptorCore(value);
            this.UpdateIndexMap();
        }
        
        protected override int CalculateRowCount() => 
            ((base.DataSource == null) ? 0 : base.DataSource.RowCount);
        
        protected internal virtual IComparer<int> CreateComparer(bool compareRowHandles)
        {
            if ((base.DataSource == null) || (this.Comparer == null))
            {
                return null;
            }
            RowComparer comparer1 = new RowComparer();
            comparer1.DataSource = base.DataSource;
            comparer1.Comparer = this.Comparer.Comparer;
            return comparer1;
        }
        
        protected override CreateIndexMapResult CreateIndexMap() => 
            this.CreateSortedIndexMap(this.CreateComparer(true), true);
        
        protected CreateIndexMapResult CreateSortedIndexMap(IComparer<int> comparer, bool syncSelection)
        {
            int num = (base.DataSource != null) ? base.DataSource.RowCount : 0;
            List<int> indexMap = new List<int>(num);
            for (int i = 0; i < num; i++)
            {
                indexMap.Add(i);
            }
            CreateIndexMapResult result = new CreateIndexMapResult {
                IndexMap = (IList<int>) indexMap,
                ShouldResetSelection = true
            };
            if (comparer != null)
            {
                base.DataSource.BeginSort();
                try
                {
                    if (this.SupportsFastSorting)
                    {
                        this.FastSortIndexMap(indexMap, this.FastSortComparer, comparer);
                    }
                    else
                    {
                        MergeSort.Sort<int>((IList<int>) indexMap, 0, indexMap.Count - 1, comparer);
                    }
                }
                finally
                {
                    base.DataSource.EndSort();
                }
            }
            if (syncSelection)
            {
                for (int j = 0; j < num; j++)
                {
                    if (base.IsSelectedSourceRow(indexMap[j]))
                    {
                        result.NewSelectionRow = j;
                        result.ShouldResetSelection = false;
                        break;
                    }
                }
            }
            return result;
        }
        
        private void FastSortIndexMap(List<int> indexMap, SortDescriptor<IRowData> descriptor, IComparer<int> defaultComparer)
        {
            this.FastSortIndexMapKnownTypes(indexMap, descriptor, defaultComparer);
        }
        
        private void FastSortIndexMapGenericField<T>(List<int> indexMap, SortDescriptor<IRowData> descriptor)
        {
            int[] rowHandles = indexMap.ToArray();
            base.DataSource.PopulateSourceRowHandles(rowHandles);
            T[] values = new T[rowHandles.Length];
            base.DataSource.PopulateColumnValues<T>(rowHandles, descriptor.FieldName, values, descriptor.FieldValueVisitor);
            MergeSort2.Sort<T>(values, 0, rowHandles.Length - 1, (IComparer<T>) Comparer<T>.Default, (IList<int>) indexMap);
        }
        
        private void FastSortIndexMapKnownTypes(List<int> indexMap, SortDescriptor<IRowData> descriptor, IComparer<int> defaultComparer)
        {
            if (((descriptor.SortMode == ColumnSortMode.DisplayText) && (descriptor.FieldValueVisitor != null)) && (descriptor.FieldValueVisitor.FieldValueType == typeof(string)))
            {
                this.FastSortIndexMapGenericField<string>(indexMap, descriptor);
            }
            else if (descriptor.FieldType == typeof(string))
            {
                this.FastSortIndexMapGenericField<string>(indexMap, descriptor);
            }
            else if (descriptor.FieldType == typeof(int))
            {
                this.FastSortIndexMapGenericField<int>(indexMap, descriptor);
            }
            else if (descriptor.FieldType == typeof(bool))
            {
                this.FastSortIndexMapGenericField<bool>(indexMap, descriptor);
            }
            else if (descriptor.FieldType == typeof(double))
            {
                this.FastSortIndexMapGenericField<double>(indexMap, descriptor);
            }
            else if (descriptor.FieldType == typeof(decimal))
            {
                this.FastSortIndexMapGenericField<decimal>(indexMap, descriptor);
            }
            else if (descriptor.FieldType == typeof(DateTime))
            {
                this.FastSortIndexMapGenericField<DateTime>(indexMap, descriptor);
            }
            else if (descriptor.FieldType == typeof(float))
            {
                this.FastSortIndexMapGenericField<float>(indexMap, descriptor);
            }
            else if (descriptor.FieldType == typeof(long))
            {
                this.FastSortIndexMapGenericField<long>(indexMap, descriptor);
            }
            else if (descriptor.FieldType == typeof(short))
            {
                this.FastSortIndexMapGenericField<short>(indexMap, descriptor);
            }
            else if (descriptor.FieldType == typeof(uint))
            {
                this.FastSortIndexMapGenericField<uint>(indexMap, descriptor);
            }
            else if (descriptor.FieldType == typeof(byte))
            {
                this.FastSortIndexMapGenericField<byte>(indexMap, descriptor);
            }
            else if (descriptor.FieldType == typeof(sbyte))
            {
                this.FastSortIndexMapGenericField<sbyte>(indexMap, descriptor);
            }
            else if (descriptor.FieldType == typeof(ulong))
            {
                this.FastSortIndexMapGenericField<ulong>(indexMap, descriptor);
            }
            else
            {
                MergeSort.Sort<int>((IList<int>) indexMap, 0, indexMap.Count - 1, defaultComparer);
            }
        }
        
        public override int GetRowHandle(int sourceRowIndex)
        {
            base.EnsureIndexMapReady();
            int rowHandle = base.DataSource.GetRowHandle(sourceRowIndex);
            int num2 = base.IndexMap.Count;
            for (int i = 0; i < num2; i++)
            {
                if (base.IndexMap[i] == rowHandle)
                {
                    return i;
                }
            }
            return -2147483648;
        }
        
        private void IncrementIndices(int from, int increment)
        {
            int num = base.IndexMap.Count;
            for (int i = 0; i < num; i++)
            {
                if (base.IndexMap[i] >= from)
                {
                    IList<int> indexMap = base.IndexMap;
                    int num3 = i;
                    indexMap[num3] = (indexMap[num3] + increment);
                }
            }
        }
        
        private int IncrementIndicesAndRemove(int from, int increment)
        {
            int num = -1;
            for (int i = base.IndexMap.Count - 1; i >= 0; i--)
            {
                if (base.IndexMap[i] > from)
                {
                    IList<int> indexMap = base.IndexMap;
                    int num3 = i;
                    indexMap[num3] = (indexMap[num3] + increment);
                }
                else if (base.IndexMap[i] == from)
                {
                    base.IndexMap.RemoveAt(i);
                    num = i;
                }
            }
            return num;
        }
        
        protected override int OnDataSourceCollectionChangedCore(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (base.IndexMap == null)
            {
                return base.OnDataSourceCollectionReset();
            }
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    return this.OnRowsAdded(e);
                
                case NotifyCollectionChangedAction.Remove:
                    return this.OnRowsRemoved(e);
                
                case NotifyCollectionChangedAction.Replace:
                    return this.OnRowsReplaced(e);
            }
            return base.OnDataSourceCollectionChangedCore(sender, e);
        }
        
        protected int OnRowReplacedCore(int sourceRowIndex, int sourceRowIndexToInsert, int from, int to, IComparer<int> comparer)
        {
            int startingIndex = -1;
            int num4 = from;
            while (true)
            {
                if (num4 <= to)
                {
                    if (base.IndexMap[num4] != sourceRowIndex)
                    {
                        num4++;
                        continue;
                    }
                    startingIndex = num4;
                }
                int num2 = base.IndexMap.BinarySearch<int>(from, startingIndex - from, sourceRowIndex, comparer);
                if (num2 < 0)
                {
                    num2 = ~num2;
                }
                if (num2 >= startingIndex)
                {
                    num2 = base.IndexMap.BinarySearch<int>(startingIndex + 1, to - startingIndex, sourceRowIndex, comparer);
                    if (num2 < 0)
                    {
                        num2 = ~num2;
                    }
                    num2--;
                }
                if (num2 == startingIndex)
                {
                    return -2147483648;
                }
                bool flag = base.SelectedRow == startingIndex;
                int selectedRow = base.SelectedRow;
                if (startingIndex <= selectedRow)
                {
                    selectedRow--;
                }
                base.IndexMap.RemoveAt(startingIndex);
                int[] changedItems = new int[] { (int) sourceRowIndex };
                CustomNotifyCollectionChangedEventArgs e = new CustomNotifyCollectionChangedEventArgs((NotifyCollectionChangedAction) NotifyCollectionChangedAction.Remove, changedItems, startingIndex);
                this.RaiseRowCollectionChanged(e);
                if (num2 <= selectedRow)
                {
                    selectedRow++;
                }
                base.IndexMap.Insert(num2, sourceRowIndexToInsert);
                if (flag)
                {
                    base.SelectedRow = Math.Max(0, num2);
                }
                else if (selectedRow != base.SelectedRow)
                {
                    base.SelectedRow = Math.Max(0, selectedRow);
                }
                int[] numArray2 = new int[] { (int) sourceRowIndexToInsert };
                e = new CustomNotifyCollectionChangedEventArgs((NotifyCollectionChangedAction) NotifyCollectionChangedAction.Add, numArray2, num2) {
                    RowHandle = num2
                };
                this.RaiseRowCollectionChanged(e);
                return e.RowHandle;
            }
        }
        
        private int OnRowsAdded(NotifyCollectionChangedEventArgs e)
        {
            if (e.NewItems.Count > 1)
            {
                return base.OnDataSourceCollectionReset();
            }
            this.IncrementIndices(e.NewStartingIndex, 1);
            int startingIndex = base.IndexMap.BinarySearch<int>(0, base.IndexMap.Count, e.NewStartingIndex, this.CreateComparer(true));
            if (startingIndex < 0)
            {
                startingIndex = ~startingIndex;
            }
            base.IndexMap.Insert(startingIndex, e.NewStartingIndex);
            if (base.SelectedRow >= startingIndex)
            {
                int selectedRow = base.SelectedRow;
                base.SelectedRow = selectedRow + 1;
            }
            int[] changedItems = new int[] { (int) e.NewStartingIndex };
            CustomNotifyCollectionChangedEventArgs args = new CustomNotifyCollectionChangedEventArgs((NotifyCollectionChangedAction) NotifyCollectionChangedAction.Add, changedItems, startingIndex) {
                RowHandle = startingIndex
            };
            this.RaiseRowCollectionChanged(args);
            return args.RowHandle;
        }
        
        private int OnRowsRemoved(NotifyCollectionChangedEventArgs e)
        {
            if (e.OldItems.Count > 1)
            {
                return base.OnDataSourceCollectionReset();
            }
            int startingIndex = this.IncrementIndicesAndRemove(e.OldStartingIndex, -1);
            if (base.SelectedRow >= startingIndex)
            {
                base.SelectedRow = Math.Max(0, base.SelectedRow - 1);
            }
            int[] changedItems = new int[] { (int) startingIndex };
            CustomNotifyCollectionChangedEventArgs args = new CustomNotifyCollectionChangedEventArgs((NotifyCollectionChangedAction) NotifyCollectionChangedAction.Remove, changedItems, startingIndex) {
                RowHandle = startingIndex
            };
            this.RaiseRowCollectionChanged(args);
            return args.RowHandle;
        }
        
        private int OnRowsReplaced(NotifyCollectionChangedEventArgs e) => 
            ((e.NewItems.Count <= 1) ? this.OnRowReplacedCore(e.NewStartingIndex, e.NewStartingIndex, 0, base.IndexMap.Count - 1, this.CreateComparer(true)) : base.OnDataSourceCollectionReset());
        
        protected void SetSortDescriptorCore(SortDescriptor<IRowData> value)
        {
            this.comparer = value;
        }
        
        public override bool SupportsSorting =>
            (base.DataSource != null);
        
        protected virtual bool SupportsFastSorting =>
            ((this.Comparer != null) && (this.Comparer.IsSingleColumn && ((this.Comparer.FieldType != null) && (this.Comparer.FieldType != typeof(object)))));
        
        protected virtual SortDescriptor<IRowData> FastSortComparer =>
            this.Comparer;
        
        public SortDescriptor<IRowData> Comparer
        {
            get => 
                this.comparer;
            set
            {
                if (!object.Equals(this.comparer, value))
                {
                    this.AssignSortDescriptor(value);
                }
            }
        }
        
        public override bool IsRowCountReady =>
            ((base.DataSource == null) || base.DataSource.IsRowCountReady);
        
        protected class RowComparer : IComparer<int>, System.ICloneable
        {
            private IRowData cachedRowX;
            private IRowData cachedRowY;
            
            public object Clone()
            {
                SortedGridDataSourceBase.RowComparer comparer1 = new SortedGridDataSourceBase.RowComparer();
                comparer1.DataSource = this.DataSource;
                comparer1.Comparer = this.Comparer;
                return comparer1;
            }
            
            public int Compare(int x, int y)
            {
                this.cachedRowX = this.DataSource.GetRow(x, this.cachedRowX);
                this.cachedRowY = this.DataSource.GetRow(y, this.cachedRowY);
                IRowData cachedRowX = this.cachedRowX;
                IRowData cachedRowY = this.cachedRowY;
                int num = this.Comparer.Compare(cachedRowX, cachedRowY);
                return ((num != 0) ? num : Comparer<int>.Default.Compare(cachedRowX.RowHandle, cachedRowY.RowHandle));
            }
            
            public IGridDataSource DataSource { get; set; }
            
            public IComparer<IRowData> Comparer { get; set; }
        }
    }
}
