// Generated by .NET Reflector from D:\workspace\mobile\hito-mobile\HitoApp\lampart_lib_dll\DevExpress.XamarinForms.Grid.dll
namespace DevExpress.XamarinForms.DataGrid.Internal
{
    using DevExpress.Compatibility.System;
    using DevExpress.Data;
    using DevExpress.Utils;
    using DevExpress.XamarinForms.DataGrid;
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Runtime.CompilerServices;
    using System.Threading;
    using System.Linq;

    public class GroupedGridDataSource : SortedGridDataSourceBase
    {
        private List<InnerGroupInfo> groups;
        private GridColumnSummaryCollection groupSummaries;
        private GroupDescriptor<IRowData> groupByComparer;
        [CompilerGenerated]
        public event RowAllowEventHandler GroupRowCollapsing;
        [CompilerGenerated]
        public event RowAllowEventHandler GroupRowExpanding;
        [CompilerGenerated]
        public event RowEventHandler GroupRowCollapsed;
        [CompilerGenerated]
        public event RowEventHandler GroupRowExpanded;
        
        private void AppendGroup(InnerGroupInfo lastGroup, CreateIndexMapResult result)
        {
            this.groups.Add(lastGroup);
        }
        
        private void AppendGroupSummaries(InnerGroupInfo group)
        {
            if (this.groupSummaries != null)
            {
                group.Summaries = this.groupSummaries.Clone();
            }
        }
        
        private int AppendNewGroupInTheMiddle(int rowSourceIndex, int groupIndex)
        {
            int firstRowIndex = this.groups.ElementAt(groupIndex).FirstRowIndex;
            base.IndexMap.Insert(firstRowIndex, rowSourceIndex);
            this.IncrementGroupIndices(groupIndex, firstRowIndex, 1, 1);
            InnerGroupInfo group = new InnerGroupInfo {
                IsCollapsed = this.AreGroupsInitiallyCollapsed,
                Index = groupIndex,
                FirstRowIndex = firstRowIndex
            };
            group.LastRowIndex = group.FirstRowIndex;
            group.FieldName = this.GroupBy.FieldName;
            group.GroupValue = this.GroupBy.GetGroupValue(base.DataSource.GetRow(rowSourceIndex, null));
            this.AppendGroupSummaries(group);
            this.groups.Insert(groupIndex, group);
            return firstRowIndex;
        }
        
        private int AppendNewGroupToEnd(int rowSourceIndex)
        {
            base.IndexMap.Add(rowSourceIndex);
            InnerGroupInfo group = new InnerGroupInfo {
                IsCollapsed = this.AreGroupsInitiallyCollapsed,
                Index = this.groups.Count,
                FirstRowIndex = base.IndexMap.Count - 1
            };
            group.LastRowIndex = group.FirstRowIndex;
            group.FieldName = this.GroupBy.FieldName;
            group.GroupValue = this.GroupBy.GetGroupValue(base.DataSource.GetRow(rowSourceIndex, null));
            this.AppendGroupSummaries(group);
            this.groups.Add(group);
            return base.IndexMap.Count;
        }
        
        public void CollapseAllGroups()
        {
            foreach (InnerGroupInfo info in this.Groups)
            {
                this.CollapseGroupCore(info);
            }
        }
        
        public void CollapseGroup(int groupRowIndex)
        {
            this.CollapseGroupCore(this.GroupByRowIndex(groupRowIndex));
        }
        
        private void CollapseGroupCore(InnerGroupInfo group)
        {
            if (!group.IsCollapsed && this.RaiseGroupRowCollapsing(group.RowHandle))
            {
                group.IsCollapsed = true;
                this.RaiseGroupRowCollapsed(group.RowHandle);
            }
        }
        
        protected internal override IComparer<int> CreateComparer(bool compareRowHandles)
        {
            if (this.GroupBy == null)
            {
                return base.CreateComparer(compareRowHandles);
            }
            if (base.DataSource == null)
            {
                return null;
            }
            GroupedRowComparer comparer1 = new GroupedRowComparer();
            comparer1.CompareRowHandles = compareRowHandles;
            comparer1.DataSource = base.DataSource;
            comparer1.GroupByComparer = this.GroupBy.Clone();
            comparer1.GroupByComparer.SortOrder = ColumnSortOrder.Ascending;
            comparer1.Comparer = base.Comparer;
            return comparer1;
        }
        
        protected internal IComparer<int> CreateGroupComparer(bool compareRowHandles)
        {
            if (this.GroupBy == null)
            {
                return base.CreateComparer(compareRowHandles);
            }
            if (base.DataSource == null)
            {
                return null;
            }
            GroupedRowComparer comparer1 = new GroupedRowComparer();
            comparer1.CompareRowHandles = compareRowHandles;
            comparer1.DataSource = base.DataSource;
            comparer1.GroupByComparer = this.GroupBy;
            return comparer1;
        }
        
        protected override CreateIndexMapResult CreateIndexMap()
        {
            IComparer<int> comparer = this.CreateComparer(true);
            CreateIndexMapResult result = base.CreateSortedIndexMap(comparer, true);
            result.IndexMap = this.CreateReversedIndexMapIfNeed(result.IndexMap);
            IList<int> indexMap = result.IndexMap;
            this.groups = new List<InnerGroupInfo>();
            if ((indexMap.Count > 0) && (this.GroupBy != null))
            {
                base.DataSource.BeginSort();
                try
                {
                    InnerGroupInfo lastGroup = null;
                    while (true)
                    {
                        InnerGroupInfo info2 = this.CreateNextGroup(lastGroup, result);
                        this.AppendGroup(info2, result);
                        if (info2.LastRowIndex == (indexMap.Count - 1))
                        {
                            break;
                        }
                        lastGroup = info2;
                    }
                }
                finally
                {
                    base.DataSource.EndSort();
                }
            }
            return result;
        }
        
        private InnerGroupInfo CreateNextGroup(InnerGroupInfo lastGroup, CreateIndexMapResult result)
        {
            InnerGroupInfo group = new InnerGroupInfo {
                Index = this.groups.Count,
                FirstRowIndex = (lastGroup == null) ? 0 : (lastGroup.LastRowIndex + 1)
            };
            IRowData row = base.DataSource.GetRow(result.IndexMap[group.FirstRowIndex], null);
            group.GroupValue = this.GroupBy.GetGroupValue(row);
            group.FieldName = this.GroupBy.FieldName;
            group.IsCollapsed = this.AreGroupsInitiallyCollapsed;
            IRowData reuseRow = null;
            int firstRowIndex = group.FirstRowIndex;
            int num2 = result.IndexMap.Count - 1;
            while (firstRowIndex <= num2)
            {
                int num3 = firstRowIndex + ((num2 - firstRowIndex) >> 1);
                reuseRow = base.DataSource.GetRow(result.IndexMap[num3], reuseRow);
                if (this.GroupBy.Compare(row, reuseRow) >= 0)
                {
                    firstRowIndex = num3 + 1;
                    continue;
                }
                num2 = num3 - 1;
            }
            group.LastRowIndex = firstRowIndex - 1;
            this.AppendGroupSummaries(group);
            return group;
        }
        
        private RangeRowComparer CreateRangeRowComparer()
        {
            RangeRowComparer comparer1 = new RangeRowComparer();
            comparer1.DataSource = base.DataSource;
            comparer1.Comparer = base.Comparer;
            return comparer1;
        }
        
        private IList<int> CreateReversedIndexMapIfNeed(IList<int> map)
        {
            if (map == null)
            {
                return null;
            }
            if (this.GroupBy == null)
            {
                return map;
            }
            ReverseOrderedList<int> list = map as ReverseOrderedList<int>;
            return ((list == null) ? ((this.GroupBy.SortOrder != ColumnSortOrder.Ascending) ? new ReverseOrderedList<int>(map) : map) : ((this.GroupBy.SortOrder != ColumnSortOrder.Ascending) ? map : list.OriginalList));
        }
        
        public void ExpandAllGroups()
        {
            foreach (InnerGroupInfo info in this.Groups)
            {
                this.ExpandGroupCore(info);
            }
        }
        
        public void ExpandGroup(int groupRowIndex)
        {
            this.ExpandGroupCore(this.GroupByRowIndex(groupRowIndex));
        }
        
        private void ExpandGroupCore(InnerGroupInfo group)
        {
            if (group.IsCollapsed && this.RaiseGroupRowExpanding(group.RowHandle))
            {
                group.IsCollapsed = false;
                this.RaiseGroupRowExpanded(group.RowHandle);
            }
        }
        
        public override IGroupInfo GetGroup(int groupHandle)
        {
            base.EnsureIndexMapReady();
            return this.Groups[groupHandle];
        }
        
        public int GetGroupedRowCount(int row) => 
            this.GroupByRowIndex(row).Count;
        
        public IGroupInfo GetGroupInfo(int rowHandle) => 
            this.GroupByRowIndex(rowHandle);
        
        public object GetGroupValue(int row) => 
            this.GroupByRowIndex(row).GroupValue;
        
        private InnerGroupInfo GroupByRowIndex(int rowIndex) => 
            ((this.groups.Count <= ~rowIndex) ? null : ((rowIndex >= 0) ? this.groups[rowIndex] : this.groups[~rowIndex]));
        
        private void IncrementGroupIndices(int fromGroupIndex, int fromGroupRowIndex, int groupIndexIncrement, int rowIndexIncrement)
        {
            for (int i = this.groups.Count - 1; i >= fromGroupIndex; i--)
            {
                InnerGroupInfo group = this.groups[i];
                this.IncrementGroupRowIndices(group, fromGroupRowIndex, rowIndexIncrement);
                if (groupIndexIncrement != 0)
                {
                    group.Index += groupIndexIncrement;
                }
            }
        }
        
        private void IncrementGroupRowIndices(InnerGroupInfo group, int from, int increment)
        {
            if (group.FirstRowIndex >= from)
            {
                group.FirstRowIndex += increment;
            }
            if (group.LastRowIndex >= from)
            {
                group.LastRowIndex += increment;
            }
        }
        
        private void IncrementIndices(int from, int increment)
        {
            int num = base.IndexMap.Count;
            for (int i = 0; i < num; i++)
            {
                int num3 = base.IndexMap[i];
                if ((num3 >= 0) && (num3 >= from))
                {
                    base.IndexMap[i] = (num3 + increment);
                }
            }
        }
        
        private int IncrementIndicesAndRemove(int from, int increment)
        {
            int num = -1;
            for (int i = this.groups.Count - 1; i >= 0; i--)
            {
                int num3 = this.IncrementIndicesAndRemove(this.groups[i], from, increment);
                if (num3 >= 0)
                {
                    num = num3;
                }
            }
            return num;
        }
        
        private int IncrementIndicesAndRemove(InnerGroupInfo group, int from, int increment)
        {
            int num = -1;
            for (int i = group.LastRowIndex; i >= group.FirstRowIndex; i--)
            {
                int num3 = base.IndexMap[i];
                if (num3 == from)
                {
                    base.IndexMap.RemoveAt(i);
                    num = i;
                }
                else if (num3 > from)
                {
                    base.IndexMap[i] = (num3 + increment);
                }
            }
            return num;
        }
        
        public bool IsGroupRow(int rowHandle) => 
            ((rowHandle < 0) ? (rowHandle != -2147483648) : false);
        
        public bool IsGroupRowCollapsed(int row) => 
            this.GroupByRowIndex(row).IsCollapsed;
        
        private InnerGroupInfo LookupGroupByRowIndex(int rowIndex)
        {
            int groupIndexByRowIndex = this.LookupGroupIndexByRowIndex(rowIndex);
            if (groupIndexByRowIndex >= 0)
            {
                return this.Groups[groupIndexByRowIndex];
            }
            groupIndexByRowIndex = ~groupIndexByRowIndex;
            return ((groupIndexByRowIndex < this.Groups.Count) ? this.Groups[groupIndexByRowIndex] : null);
        }
        
        private int LookupGroupIndexByRowIndex(int rowIndex) => 
            Algorithms.BinarySearch<InnerGroupInfo>((IList<InnerGroupInfo>) this.groups, new GroupInfoAndRowIndexComparable(rowIndex));
        
        private int LookupGroupIndexBySourceRowIndex(int sourceRowIndex) => 
            Algorithms.BinarySearch<InnerGroupInfo>((IList<InnerGroupInfo>) this.groups, new GroupInfoAndSourceIndexComparable(sourceRowIndex, this.CreateGroupComparer(false), base.IndexMap));
        
        protected override int OnDataSourceCollectionChangedCore(object sender, NotifyCollectionChangedEventArgs e)
        {
            if (base.IndexMap == null)
            {
                return base.OnDataSourceCollectionReset();
            }
            switch (e.Action)
            {
                case NotifyCollectionChangedAction.Add:
                    return this.OnRowsAdded(e);
                
                case NotifyCollectionChangedAction.Remove:
                    return this.OnRowsRemoved(e);
                
                case NotifyCollectionChangedAction.Replace:
                    return this.OnRowsReplaced(e);
            }
            return base.OnDataSourceCollectionChangedCore(sender, e);
        }
        
        public void OnGroupSummariesChanged(GridColumnSummaryCollection newGroupSummaries)
        {
            this.groupSummaries = newGroupSummaries;
            if (this.Groups != null)
            {
                int num = this.Groups.Count;
                for (int i = 0; i < num; i++)
                {
                    if (this.groupSummaries == null)
                    {
                        this.groups[i].Summaries = null;
                    }
                    else
                    {
                        GridColumnSummaryCollection summarys = this.groupSummaries.Clone();
                        summarys.RowHandleFrom = this.groups[i].FirstRowIndex;
                        summarys.RowHandleTo = this.groups[i].LastRowIndex;
                        this.groups[i].Summaries = summarys;
                    }
                }
            }
        }
        
        private int OnRowAddedCore(int rowSourceIndex)
        {
            int selectedRow;
            this.IncrementIndices(rowSourceIndex, 1);
            int groupIndexBySourceRowIndex = this.LookupGroupIndexBySourceRowIndex(rowSourceIndex);
            if (groupIndexBySourceRowIndex < 0)
            {
                groupIndexBySourceRowIndex = ~groupIndexBySourceRowIndex;
                int num2 = (groupIndexBySourceRowIndex < this.groups.Count) ? this.AppendNewGroupInTheMiddle(rowSourceIndex, groupIndexBySourceRowIndex) : this.AppendNewGroupToEnd(rowSourceIndex);
                if (base.SelectedRow >= num2)
                {
                    selectedRow = base.SelectedRow;
                    base.SelectedRow = selectedRow + 1;
                }
                int[] numArray1 = new int[] { (int) num2 };
                CustomNotifyCollectionChangedEventArgs args = new CustomNotifyCollectionChangedEventArgs((NotifyCollectionChangedAction) NotifyCollectionChangedAction.Add, numArray1, num2) {
                    RowHandle = num2
                };
                this.RaiseRowCollectionChanged(args);
                return args.RowHandle;
            }
            InnerGroupInfo info = this.groups[groupIndexBySourceRowIndex];
            int startingIndex = base.IndexMap.BinarySearch<int>(info.FirstRowIndex, info.Count, rowSourceIndex, this.CreateRangeRowComparer());
            if (startingIndex < 0)
            {
                startingIndex = ~startingIndex;
            }
            int num5 = rowSourceIndex;
            base.IndexMap.Insert(startingIndex, num5);
            info.LastRowIndex++;
            this.IncrementGroupIndices(info.Index + 1, info.LastRowIndex, 0, 1);
            if (base.SelectedRow >= startingIndex)
            {
                selectedRow = base.SelectedRow;
                base.SelectedRow = selectedRow + 1;
            }
            int[] changedItems = new int[] { (int) num5 };
            CustomNotifyCollectionChangedEventArgs e = new CustomNotifyCollectionChangedEventArgs((NotifyCollectionChangedAction) NotifyCollectionChangedAction.Add, changedItems, startingIndex) {
                RowHandle = startingIndex
            };
            this.RaiseRowCollectionChanged(e);
            return e.RowHandle;
        }
        
        private int OnRowsAdded(NotifyCollectionChangedEventArgs e) => 
            ((e.NewItems.Count <= 1) ? this.OnRowAddedCore(e.NewStartingIndex) : base.OnDataSourceCollectionReset());
        
        private int OnRowsRemoved(NotifyCollectionChangedEventArgs e) => 
            ((e.OldItems.Count <= 1) ? this.OnRowsRemovedCore(e.OldStartingIndex) : base.OnDataSourceCollectionReset());
        
        private int OnRowsRemovedCore(int rowSourceIndex)
        {
            int removedRowIndex = this.IncrementIndicesAndRemove(rowSourceIndex, -1);
            if (base.SelectedRow > removedRowIndex)
            {
                base.SelectedRow = Math.Max(0, base.SelectedRow - 1);
            }
            this.UpdateGroupsAfterRowRemove(removedRowIndex);
            int[] changedItems = new int[] { (int) removedRowIndex };
            CustomNotifyCollectionChangedEventArgs e = new CustomNotifyCollectionChangedEventArgs((NotifyCollectionChangedAction) NotifyCollectionChangedAction.Remove, changedItems, removedRowIndex) {
                RowHandle = removedRowIndex
            };
            this.RaiseRowCollectionChanged(e);
            return e.RowHandle;
        }
        
        private int OnRowsReplaced(NotifyCollectionChangedEventArgs e)
        {
            if (e.NewItems.Count > 1)
            {
                return base.OnDataSourceCollectionReset();
            }
            int index = base.IndexMap.IndexOf(e.NewStartingIndex);
            int groupIndexByRowIndex = this.LookupGroupIndexByRowIndex(index);
            IRowData row = base.DataSource.GetRow(e.NewStartingIndex, null);
            InnerGroupInfo info = this.Groups[groupIndexByRowIndex];
            if (object.Equals(info.GroupValue, this.GroupBy.GetGroupValue(row)))
            {
                int sourceRowIndexToInsert = e.NewStartingIndex;
                return base.OnRowReplacedCore(e.NewStartingIndex, sourceRowIndexToInsert, info.FirstRowIndex, info.LastRowIndex, this.CreateRangeRowComparer());
            }
            this.OnRowsRemovedCore(e.NewStartingIndex);
            return this.OnRowAddedCore(e.NewStartingIndex);
        }
        
        protected virtual void RaiseGroupRowCollapsed(int rowHandle)
        {
            if (this.GroupRowCollapsed != null)
            {
                RowEventArgs e = new RowEventArgs(rowHandle);
                this.GroupRowCollapsed(this, e);
            }
        }
        
        protected virtual bool RaiseGroupRowCollapsing(int rowHandle)
        {
            if (this.GroupRowCollapsing == null)
            {
                return true;
            }
            RowAllowEventArgs e = new RowAllowEventArgs(rowHandle);
            this.GroupRowCollapsing(this, e);
            return e.Allow;
        }
        
        protected virtual void RaiseGroupRowExpanded(int rowHandle)
        {
            if (this.GroupRowExpanded != null)
            {
                RowEventArgs e = new RowEventArgs(rowHandle);
                this.GroupRowExpanded(this, e);
            }
        }
        
        protected virtual bool RaiseGroupRowExpanding(int rowHandle)
        {
            if (this.GroupRowExpanding == null)
            {
                return true;
            }
            RowAllowEventArgs e = new RowAllowEventArgs(rowHandle);
            this.GroupRowExpanding(this, e);
            return e.Allow;
        }
        
        internal void ResetGroupSummaries()
        {
            if (this.Groups != null)
            {
                using (List<InnerGroupInfo>.Enumerator enumerator = this.Groups.GetEnumerator())
                {
                    while (enumerator.MoveNext())
                    {
                        enumerator.Current.Summaries.Reset();
                    }
                }
            }
        }
        
        protected internal override void ResetIndexMap()
        {
            base.ResetIndexMap();
            this.groups = null;
        }
        
        public override void ResetSelection()
        {
            if ((this.Groups == null) || (this.Groups.Count <= 0))
            {
                base.ResetSelection();
            }
            else
            {
                base.SelectedRow = 1;
            }
        }
        
        public int RevealRowHandle(int rowHandle) => 
            this.TranslateRowIndex(rowHandle);
        
        private void SortIndexMapRange(int from, int to, IComparer<int> comparer, CreateIndexMapResult what)
        {
            if ((to - from) > 0)
            {
                MergeSort.Sort<int>(what.IndexMap, from, to, comparer);
                if ((what.ShouldResetSelection && (base.SelectedRow >= from)) && (base.SelectedRow <= to))
                {
                    for (int i = from; i <= to; i++)
                    {
                        if (base.IsSelectedSourceRow(what.IndexMap[i]))
                        {
                            what.ShouldResetSelection = false;
                            what.NewSelectionRow = i;
                            return;
                        }
                    }
                }
            }
        }
        
        protected override int TranslateRowIndex(int rowHandle)
        {
            int num = base.TranslateRowIndex(rowHandle);
            int num2 = num;
            return num;
        }
        
        private bool UpdateGroupsAfterRowRemove(int removedRowIndex)
        {
            InnerGroupInfo info = null;
            int fromGroupIndex = -1;
            for (int i = this.groups.Count - 1; i >= 0; i--)
            {
                InnerGroupInfo group = this.groups[i];
                this.IncrementGroupRowIndices(group, removedRowIndex, -1);
                if (group.FirstRowIndex == removedRowIndex)
                {
                    if (group.Count != 1)
                    {
                        group.FirstRowIndex++;
                    }
                    else
                    {
                        fromGroupIndex = i;
                        info = group;
                        this.groups.RemoveAt(i);
                    }
                }
            }
            if (fromGroupIndex < 0)
            {
                return false;
            }
            this.IncrementGroupIndices(fromGroupIndex, info.FirstRowIndex, -1, 0);
            return true;
        }
        
        protected override void UpdateIndexMap()
        {
            if ((this.groups == null) || (this.groups.Count <= 0))
            {
                base.UpdateIndexMap();
            }
            else
            {
                RangeRowComparer comparer = this.CreateRangeRowComparer();
                CreateIndexMapResult what = new CreateIndexMapResult {
                    IndexMap = base.IndexMap,
                    ShouldResetSelection = true
                };
                int recordCount = this.groups.Count;
                base.DataSource.BeginSort();
                try
                {
                    for (int i = 0; i < recordCount; i++)
                    {
                        InnerGroupInfo info = this.groups[i];
                        this.SortIndexMapRange(info.FirstRowIndex, info.LastRowIndex, comparer, what);
                    }
                }
                finally
                {
                    base.DataSource.EndSort();
                }
                if (what.ShouldResetSelection)
                {
                    base.ResetSelection(recordCount);
                }
                else
                {
                    base.SetSelectedRowCore(what.NewSelectionRow, false);
                }
            }
        }
        
        public bool AreGroupsInitiallyCollapsed { get; set; }
        
        public override bool SupportsGrouping =>
            (base.DataSource != null);
        
        protected override bool SupportsFastSorting
        {
            get
            {
                if (((base.Comparer != null) || ((this.GroupBy == null) || (!this.GroupBy.IsSingleColumn || (this.GroupBy.FieldType == null)))) || (this.GroupBy.FieldType == typeof(object)))
                {
                    return false;
                }
                RowDataGroupDescriptor groupBy = this.GroupBy as RowDataGroupDescriptor;
                return ((groupBy == null) || !groupBy.CanChangeDataType());
            }
        }
        
        protected override SortDescriptor<IRowData> FastSortComparer =>
            this.GroupBy;
        
        internal List<InnerGroupInfo> Groups =>
            this.groups;
        
        public GroupDescriptor<IRowData> GroupBy
        {
            get => 
                this.groupByComparer;
            set
            {
                if (!object.Equals(this.groupByComparer, value))
                {
                    this.groupByComparer = value;
                    this.ResetIndexMap();
                }
            }
        }
        
        public GridColumnSummaryCollection GroupSummaries
        {
            get => 
                this.groupSummaries;
            set
            {
                this.groupSummaries = value;
                this.ResetIndexMap();
            }
        }
        
        public override int GroupCount
        {
            get
            {
                if (base.DataSource == null)
                {
                    return 0;
                }
                base.EnsureIndexMapReady();
                return ((this.groups != null) ? this.groups.Count : 0);
            }
        }
        
        private class GroupedRowComparer : IComparer<int>, System.ICloneable
        {
            private IRowData cachedRowX;
            private IRowData cachedRowY;
            
            public object Clone()
            {
                GroupedGridDataSource.GroupedRowComparer comparer1 = new GroupedGridDataSource.GroupedRowComparer();
                comparer1.DataSource = this.DataSource;
                comparer1.GroupByComparer = this.GroupByComparer;
                comparer1.Comparer = this.Comparer;
                comparer1.CompareRowHandles = this.CompareRowHandles;
                return comparer1;
            }
            
            public int Compare(int x, int y)
            {
                this.cachedRowX = this.DataSource.GetRow(x, this.cachedRowX);
                this.cachedRowY = this.DataSource.GetRow(y, this.cachedRowY);
                IRowData cachedRowX = this.cachedRowX;
                IRowData cachedRowY = this.cachedRowY;
                int num = this.GroupByComparer.Compare(cachedRowX, cachedRowY);
                if (num != 0)
                {
                    return num;
                }
                if (this.Comparer == null)
                {
                    return (!this.CompareRowHandles ? num : Comparer<int>.Default.Compare(cachedRowX.RowHandle, cachedRowY.RowHandle));
                }
                num = this.Comparer.Compare(cachedRowX, cachedRowY);
                if ((num != 0) || !this.CompareRowHandles)
                {
                    return num;
                }
                return Comparer<int>.Default.Compare(cachedRowX.RowHandle, cachedRowY.RowHandle);
            }
            
            public IGridDataSource DataSource { get; set; }
            
            public SortDescriptor<IRowData> GroupByComparer { get; set; }
            
            public SortDescriptor<IRowData> Comparer { get; set; }
            
            public bool CompareRowHandles { get; set; }
        }
        
        private class GroupInfoAndRowIndexComparable : IComparable<InnerGroupInfo>
        {
            private readonly int rowIndex;
            
            public GroupInfoAndRowIndexComparable(int rowIndex)
            {
                this.rowIndex = rowIndex;
            }
            
            public int CompareTo(InnerGroupInfo other)
            {
                if ((other.FirstRowIndex > this.rowIndex) || (this.rowIndex > other.LastRowIndex))
                {
                    return Comparer<int>.Default.Compare(this.rowIndex, other.FirstRowIndex);
                }
                return 0;
            }
        }
        
        private class GroupInfoAndSourceIndexComparable : IComparable<InnerGroupInfo>
        {
            private readonly IComparer<int> groupAndSortComparer;
            private readonly int sourceRowIndex;
            private readonly IList<int> indexMap;
            
            public GroupInfoAndSourceIndexComparable(int sourceRowIndex, IComparer<int> groupAndSortComparer, IList<int> indexMap)
            {
                this.sourceRowIndex = sourceRowIndex;
                this.groupAndSortComparer = groupAndSortComparer;
                this.indexMap = indexMap;
            }
            
            public int CompareTo(InnerGroupInfo other) => 
                this.groupAndSortComparer.Compare(this.sourceRowIndex, this.indexMap[other.FirstRowIndex]);
        }
        
        private class RangeRowComparer : IComparer<int>, System.ICloneable
        {
            private IRowData cachedRowX;
            private IRowData cachedRowY;
            
            private int CalculateActualRowIndex(int value) => 
                value;
            
            public object Clone()
            {
                GroupedGridDataSource.RangeRowComparer comparer1 = new GroupedGridDataSource.RangeRowComparer();
                comparer1.DataSource = this.DataSource;
                comparer1.Comparer = this.Comparer;
                return comparer1;
            }
            
            public int Compare(int x, int y)
            {
                int num1 = this.CalculateActualRowIndex(x);
                x = num1;
                int num2 = this.CalculateActualRowIndex(y);
                y = num2;
                this.cachedRowX = this.DataSource.GetRow(x, this.cachedRowX);
                this.cachedRowY = this.DataSource.GetRow(y, this.cachedRowY);
                IRowData cachedRowX = this.cachedRowX;
                IRowData cachedRowY = this.cachedRowY;
                return ((this.Comparer == null) ? Comparer<int>.Default.Compare(x, y) : this.Comparer.Compare(cachedRowX, cachedRowY));
            }
            
            public IGridDataSource DataSource { get; set; }
            
            public SortDescriptor<IRowData> Comparer { get; set; }
        }
    }
}
