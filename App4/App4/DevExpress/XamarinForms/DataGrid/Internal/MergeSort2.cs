// Generated by .NET Reflector from D:\workspace\mobile\hito-mobile\HitoApp\lampart_lib_dll\DevExpress.XamarinForms.Grid.dll
namespace DevExpress.XamarinForms.DataGrid.Internal
{
    using DevExpress.Compatibility.System;
    using DevExpress.XamarinForms.Core;
    using System;
    using System.Collections.Generic;
    
    public static class MergeSort2
    {
        private const int MaxSequentialElementCount = 0x400;
        
        private static int GetMaxDepth() => 
            Math.Max(0, (int) Math.Round(Math.Log((double) Environment.get_ProcessorCount(), (double) 2.0)));
        
        private static void ParallelSort<T>(IList<T> list, int from, int to, IComparer<T> comparer, int depth, T[] buffer, IList<int> indexArray, int[] indexBuffer, IParallelService service)
        {
            if ((((to - from) + 1) <= 0x400) || (depth <= 0))
            {
                SequentialSort<T>(list, from, to, comparer, buffer, indexArray, indexBuffer);
            }
            else if (to > from)
            {
                int mid = (from + to) / 2;
                depth--;
                IComparer<T> comparer2 = comparer;
                ICloneable cloneable = comparer2 as ICloneable;
                if (cloneable != null)
                {
                    comparer2 = (IComparer<T>) cloneable.Clone();
                }
                Action[] actions = new Action[] { delegate {
                    ParallelSort<T>(list, from, mid, comparer, depth, buffer, indexArray, indexBuffer, service);
                }, delegate {
                    ParallelSort<T>(list, mid + 1, to, comparer2, depth, buffer, indexArray, indexBuffer, service);
                } };
                service.Invoke(actions);
                SequentialMerge<T>(list, from, mid, to, comparer, buffer, indexArray, indexBuffer);
            }
        }
        
        private static void SequentialMerge<T>(IList<T> array, int left, int mid, int right, IComparer<T> comparer, T[] buffer, IList<int> indexArray, int[] indexBuffer)
        {
            T[] localArray = buffer;
            int[] numArray = indexBuffer;
            int num = (array.get_Count() == buffer.Length) ? left : 0;
            int index = num;
            int num3 = left;
            int num4 = mid + 1;
            while ((num3 <= mid) && (num4 <= right))
            {
                if (comparer.Compare(array.get_Item(num3), array.get_Item(num4)) <= 0)
                {
                    localArray[index] = array.get_Item(num3);
                    index++;
                    num3++;
                    numArray[index] = indexArray.get_Item(num3);
                    continue;
                }
                localArray[index] = array.get_Item(num4);
                index++;
                num4++;
                numArray[index] = indexArray.get_Item(num4);
            }
            while (num3 <= mid)
            {
                localArray[index] = array.get_Item(num3);
                index++;
                num3++;
                numArray[index] = indexArray.get_Item(num3);
            }
            while (num4 <= right)
            {
                localArray[index] = array.get_Item(num4);
                index++;
                num4++;
                numArray[index] = indexArray.get_Item(num4);
            }
            if (num == 0)
            {
                for (int i = 0; i < index; i++)
                {
                    array.set_Item((int) (i + left), localArray[i]);
                    indexArray.set_Item((int) (i + left), numArray[i]);
                }
            }
            else
            {
                for (int i = left; i < index; i++)
                {
                    array.set_Item(i, localArray[i]);
                    indexArray.set_Item(i, numArray[i]);
                }
            }
        }
        
        private static void SequentialSort<T>(IList<T> list, int from, int to, IComparer<T> comparer, T[] buffer, IList<int> index, int[] indexBuffer)
        {
            if (to > from)
            {
                int num = (from + to) / 2;
                SequentialSort<T>(list, from, num, comparer, buffer, index, indexBuffer);
                SequentialSort<T>(list, num + 1, to, comparer, buffer, index, indexBuffer);
                SequentialMerge<T>(list, from, num, to, comparer, buffer, index, indexBuffer);
            }
        }
        
        public static void Sort<T>(IList<T> list, int from, int to, IComparer<T> comparer, IList<int> indexArray)
        {
            IParallelService service = GlobalServices.Instance.GetService<IParallelService>();
            T[] buffer = new T[(to - from) + 1];
            int[] indexBuffer = new int[(to - from) + 1];
            DateTime.get_Now();
            if ((((to - from) + 1) <= 0x400) || (service == null))
            {
                SequentialSort<T>(list, from, to, comparer, buffer, indexArray, indexBuffer);
            }
            else
            {
                ParallelSort<T>(list, from, to, comparer, GetMaxDepth(), buffer, indexArray, indexBuffer, service);
            }
        }
    }
}
