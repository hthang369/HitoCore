// Generated by .NET Reflector from D:\workspace\mobile\hito-mobile\HitoApp\lampart_lib_dll\DevExpress.XamarinForms.Grid.dll
namespace DevExpress.XamarinForms.DataGrid.Internal
{
    using DevExpress.Data;
    using DevExpress.XamarinForms.DataGrid;
    using System;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Runtime.CompilerServices;
    using System.Runtime.InteropServices;
    using System.Threading;
    
    public class UnboundColumnsDataSource : IGridDataSource, IGridDataSourceSupportSortCache
    {
        private IGridDataSource dataSource;
        private readonly Dictionary<string, Func<IRowData, object>> unboundFields = new Dictionary<string, Func<IRowData, object>>();
        private readonly Dictionary<string, Action<IRowData, object>> unboundFieldsSetters = new Dictionary<string, Action<IRowData, object>>();
        private static readonly Func<IRowData, object> undefined = delegate (IRowData row) {
            return null;
        };
        private static readonly Action<IRowData, object> undefinedSetter = delegate (IRowData row, object value) {
        };
        private NotifyCollectionChangedEventHandler onRowCollectionChanged;
        private NotifyCollectionChangedEventHandler onGroupCollectionChanged;
        [CompilerGenerated]
        public CreateUnboundFieldFunctionEventHandler CreateUnboundFieldFunction;
        [CompilerGenerated]
        public CreateUnboundFieldFunctionEventHandler CreateUnboundFieldSetter;
        private int sortTransactionCount;
        private Dictionary<string, Dictionary<int, object>> valuesCache = new Dictionary<string, Dictionary<int, object>>();
        
        event NotifyCollectionChangedEventHandler IGridDataSource.GroupCollectionChanged
        {
            add
            {
                this.onGroupCollectionChanged = (NotifyCollectionChangedEventHandler) Delegate.Combine((Delegate) this.onGroupCollectionChanged, (Delegate) value);
            }
            remove
            {
                this.onGroupCollectionChanged = (NotifyCollectionChangedEventHandler) Delegate.Remove((Delegate) this.onGroupCollectionChanged, (Delegate) value);
            }
        }
        
        event NotifyCollectionChangedEventHandler IGridDataSource.RowCollectionChanged
        {
            add
            {
                this.onRowCollectionChanged = (NotifyCollectionChangedEventHandler) Delegate.Combine((Delegate) this.onRowCollectionChanged, (Delegate) value);
            }
            remove
            {
                this.onRowCollectionChanged = (NotifyCollectionChangedEventHandler) Delegate.Remove((Delegate) this.onRowCollectionChanged, (Delegate) value);
            }
        }
        
        public UnboundColumnsDataSource(IGridDataSource dataSource)
        {
            this.DataSource = dataSource;
        }
        
        public int AddNewRow(IEditableRowData rowData)
        {
            this.ResetValuesCache();
            GridRowData data = rowData as GridRowData;
            return ((data != null) ? this.dataSource.AddNewRow(data.InnerRowData as IEditableRowData) : this.dataSource.AddNewRow(rowData));
        }
        
        public void BeginSort()
        {
        }
        
        public IEditableRowData CreateNewRow()
        {
            IEditableRowData data = this.dataSource.CreateNewRow();
            if (data == null)
            {
                return null;
            }
            GridRowData data1 = new GridRowData(this);
            data1.InnerRowData = data;
            return data1;
        }
        
        public int DeleteRow(int rowHandle)
        {
            if (this.dataSource == null)
            {
                return -2147483648;
            }
            this.ResetValuesCache();
            return this.dataSource.DeleteRow(rowHandle);
        }
        
        IGroupInfo IGridDataSource.GetGroup(int groupHandle)
        {
            if ((this.DataSource == null) || !this.DataSource.SupportsGrouping)
            {
                return null;
            }
            return this.DataSource.GetGroup(groupHandle);
        }
        
        public void EndSort()
        {
        }
        
        public IRowData GetRow(int rowHandle, IRowData reuseRow)
        {
            if (!this.HasUnboundColumns)
            {
                return this.dataSource.GetRow(rowHandle, reuseRow);
            }
            GridRowData data = reuseRow as GridRowData;
            if (data == null)
            {
                data = new GridRowData(this);
            }
            data.InnerRowData = this.dataSource.GetRow(rowHandle, data.InnerRowData);
            return ((data.InnerRowData != null) ? data : null);
        }
        
        private void OnDataSourceGroupCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.ResetValuesCache();
            this.RaiseGroupCollectionChanged(CustomNotifyCollectionChangedEventArgs.Create(e));
        }
        
        private void OnDataSourceRowCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
        {
            this.ResetValuesCache();
            this.RaiseRowCollectionChanged(CustomNotifyCollectionChangedEventArgs.Create(e));
        }
        
        private void PopulateBoundColumnValues<T>(int[] rowHandles, string fieldName, T[] values, IFieldValueVisitor fieldValueVisitor)
        {
            IRowData reuseRow = null;
            int length = rowHandles.Length;
            if ((fieldValueVisitor == null) || (fieldValueVisitor.ActualSortMode != ColumnSortMode.DisplayText))
            {
                for (int i = 0; i < length; i++)
                {
                    reuseRow = this.GetRow(rowHandles[i], reuseRow);
                    values[i] = reuseRow.GetFieldValueGeneric<T>(fieldName);
                }
            }
            else
            {
                for (int i = 0; i < length; i++)
                {
                    reuseRow = this.GetRow(rowHandles[i], reuseRow);
                    values[i] = (T) fieldValueVisitor.GetFormattedFieldValue(reuseRow);
                }
            }
        }
        
        public void PopulateColumnValues<T>(int[] rowHandles, string fieldName, T[] values, IFieldValueVisitor fieldValueVisitor)
        {
            Func<IRowData, object> unboundField = this.TryGetUnboundField(fieldName);
            if (unboundField != null)
            {
                this.PopulateUnboundColumnValues<T>(unboundField, rowHandles, values);
            }
            else
            {
                this.PopulateBoundColumnValues<T>(rowHandles, fieldName, values, fieldValueVisitor);
            }
        }
        
        private void PopulateUnboundColumnValues<T>(Func<IRowData, object> unboundField, int[] rowHandles, T[] values)
        {
            IRowData reuseRow = null;
            int length = rowHandles.Length;
            for (int i = 0; i < length; i++)
            {
                reuseRow = this.GetRow(rowHandles[i], reuseRow);
                values[i] = (T) unboundField(reuseRow);
            }
        }
        
        private Func<IRowData, object> RaiseCreateUnboundFieldFunction(string fieldName)
        {
            if (this.CreateUnboundFieldFunction == null)
            {
                return undefined;
            }
            CreateUnboundFieldFunctionEventArgs e = new CreateUnboundFieldFunctionEventArgs {
                FieldName = fieldName
            };
            this.CreateUnboundFieldFunction(this, e);
            return ((e.Function != null) ? e.Function : undefined);
        }
        
        private Action<IRowData, object> RaiseCreateUnboundFieldSetter(string fieldName)
        {
            if (this.CreateUnboundFieldFunction == null)
            {
                return undefinedSetter;
            }
            CreateUnboundFieldFunctionEventArgs e = new CreateUnboundFieldFunctionEventArgs {
                FieldName = fieldName
            };
            this.CreateUnboundFieldSetter(this, e);
            return ((e.Setter != null) ? e.Setter : undefinedSetter);
        }
        
        protected virtual void RaiseGroupCollectionChanged(CustomNotifyCollectionChangedEventArgs e)
        {
            if (this.onGroupCollectionChanged != null)
            {
                this.onGroupCollectionChanged(this, e);
            }
        }
        
        protected virtual void RaiseRowCollectionChanged(CustomNotifyCollectionChangedEventArgs e)
        {
            if (this.onRowCollectionChanged != null)
            {
                this.onRowCollectionChanged(this, e);
            }
        }
        
        private void ResetValuesCache()
        {
            if (this.sortTransactionCount > 0)
            {
                this.valuesCache.Clear();
            }
        }
        
        private void SaveCachedValue(IRowData rowData, string fieldName, object value)
        {
            if (this.sortTransactionCount > 0)
            {
                Dictionary<string, Dictionary<int, object>> valuesCache = this.valuesCache;
                lock (valuesCache)
                {
                    Dictionary<int, object> dictionary2;
                    if (!this.valuesCache.TryGetValue(fieldName, out dictionary2))
                    {
                        dictionary2 = new Dictionary<int, object>();
                        this.valuesCache.Add(fieldName, dictionary2);
                    }
                    dictionary2[rowData.RowHandle] = value;
                }
            }
        }
        
        private void SubscribeDataSourceEvents()
        {
            if (this.DataSource != null)
            {
                this.DataSource.RowCollectionChanged += new NotifyCollectionChangedEventHandler(this.OnDataSourceRowCollectionChanged);
                this.dataSource.GroupCollectionChanged += new NotifyCollectionChangedEventHandler(this.OnDataSourceGroupCollectionChanged);
            }
        }
        
        private bool TryGetCachedValue(IRowData rowData, string fieldName, out object value)
        {
            Dictionary<int, object> dictionary;
            if (this.sortTransactionCount <= 0)
            {
                value = null;
                return false;
            }
            if (this.valuesCache.TryGetValue(fieldName, out dictionary))
            {
                return dictionary.TryGetValue(rowData.RowHandle, out value);
            }
            value = null;
            return false;
        }
        
        public Func<IRowData, object> TryGetUnboundField(string fieldName)
        {
            Func<IRowData, object> func;
            if (!this.unboundFields.TryGetValue(fieldName, out func))
            {
                return null;
            }
            if (func == null)
            {
                func = this.RaiseCreateUnboundFieldFunction(fieldName);
                this.unboundFields[fieldName] = func;
            }
            return func;
        }
        
        public Action<IRowData, object> TryGetUnboundFieldSetter(string fieldName)
        {
            Action<IRowData, object> action;
            if (!this.unboundFieldsSetters.TryGetValue(fieldName, out action))
            {
                return null;
            }
            if (action == null)
            {
                action = this.RaiseCreateUnboundFieldSetter(fieldName);
                this.unboundFieldsSetters[fieldName] = action;
            }
            return action;
        }
        
        public bool TryGetUnboundFieldValue(IRowData rowData, string fieldName, out object value)
        {
            if (!this.TryGetCachedValue(rowData, fieldName, out value))
            {
                Func<IRowData, object> func = this.TryGetUnboundField(fieldName);
                if (func == null)
                {
                    value = null;
                    return false;
                }
                value = func(rowData);
                if (this.sortTransactionCount > 0)
                {
                    this.SaveCachedValue(rowData, fieldName, value);
                }
            }
            return true;
        }
        
        private void UnsubscribeDataSourceEvents()
        {
            if (this.DataSource != null)
            {
                this.DataSource.RowCollectionChanged -= new NotifyCollectionChangedEventHandler(this.OnDataSourceRowCollectionChanged);
                this.dataSource.GroupCollectionChanged -= new NotifyCollectionChangedEventHandler(this.OnDataSourceGroupCollectionChanged);
            }
        }
        
        public void UpdateUnboundFields(GridColumnCollection columns)
        {
            this.UnboundFields.Clear();
            this.UnboundFieldsSetters.Clear();
            foreach (GridColumn column in columns)
            {
                if (column.IsUnbound)
                {
                    this.UnboundFields.Add(column.FieldName, null);
                    this.UnboundFieldsSetters.Add(column.FieldName, null);
                }
            }
            this.ResetValuesCache();
        }
        
        private Dictionary<string, Func<IRowData, object>> UnboundFields =>
            this.unboundFields;
        
        private Dictionary<string, Action<IRowData, object>> UnboundFieldsSetters =>
            this.unboundFieldsSetters;
        
        private bool HasUnboundColumns =>
            (this.UnboundFields.Count > 0);
        
        public IGridDataSource DataSource
        {
            get => 
                this.dataSource;
            set
            {
                if (!object.ReferenceEquals(this.dataSource, value))
                {
                    if (value == null)
                    {
                        value = new EmptyGridDataSource();
                    }
                    this.UnsubscribeDataSourceEvents();
                    this.dataSource = value;
                    this.dataSource.SelectedRow = this.SelectedRow;
                    this.SubscribeDataSourceEvents();
                    this.ResetValuesCache();
                }
            }
        }
        
        public bool SupportsSorting =>
            this.dataSource.SupportsSorting;
        
        public bool SupportsGrouping =>
            this.dataSource.SupportsGrouping;
        
        public bool SupportsFiltering =>
            this.dataSource.SupportsFiltering;
        
        public int RowCount =>
            this.dataSource.RowCount;
        
        public int SelectedRow
        {
            get => 
                this.dataSource.SelectedRow;
            set => 
                this.dataSource.SelectedRow = value;
        }
        
        public Type ActualDataSourceType =>
            ((this.DataSource == null) ? base.GetType() : this.DataSource.ActualDataSourceType);
        
        int IGridDataSource.GroupCount
        {
            get
            {
                if ((this.DataSource == null) || !this.DataSource.SupportsGrouping)
                {
                    return 0;
                }
                return this.DataSource.GroupCount;
            }
        }
    }
}
